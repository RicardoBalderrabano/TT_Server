""" Facial Recognizer
This script performs face recognition using the 
face database generated by trainer.py.
The algorithm used is based on ResNet-34 from 
the Deep Residual Learning for Image Recognition paper 
(https://arxiv.org/pdf/1512.03385.pdf) by He et al., 2015.
The network was trained by Davis King, the creator of 
dlib library.
(http://blog.dlib.net/2017/02/high-quality-face-recognition-with-deep.html)
Acording to Davis, the network was trained from scratch 
on a dataset of about 3 million faces and the pretrained 
model is in the public domain. Also, the model has an 
accuracy of 99.38% on the standard Labeled Faces in the 
Wild benchmark, i.e. given two face images, it correctly 
predicts if the images are of the same person 99.38% of 
the time.
Also, this script make use of face_recogniton module,
created by Adam Geitgey.
(https://medium.com/@ageitgey/machine-learning-is-fun-part-4-modern-face-recognition-with-deep-learning-c3cffc121d78)
In his article, he describe the whole process for face 
recognition.
All this information, and more, can be found in this greate
article: https://pyimagesearch.com/2018/06/18/face-recognition-with-opencv-python-and-deep-learning/
by Adrian Rosebrock.
"""

import imutils
import cv2
import face_recognition
import pickle
import os
import numpy as np

# set 1 for macOS, maybe 0 for windows and others

FACEDB = "/home/ubuntu/tests/facedatabase2.dat"  # name of the database

file_dir = os.path.dirname(os.path.realpath(__file__))
FACEDB = os.path.join(file_dir, FACEDB)
FACEDB = os.path.abspath(os.path.realpath(FACEDB))

# confidence 
conf = 0.5
maxImgs = 100

# load the faces database
print("Loading faces database...")
faceData = pickle.loads(open(FACEDB, "rb").read())

#define the face_encodings
fenco=[-0.16204873,  0.05700064,  0.09044103, -0.0289933,  0.0105991, -0.06313304,  0.02532312, -0.06310672,  0.19280991, -0.06976435,0.27877778, -0.02801619, -0.16462296, -0.08764254,  0.0184108 ,0.10018795, -0.1614228 , -0.07778311, -0.05854391, -0.09281124,0.03796965, -0.06505482,  0.08574302,  0.08136091, -0.13039035,-0.33689976, -0.12185112, -0.17633946,  0.04835968, -0.12887856, 0.03734888, -0.03419122, -0.13015796, -0.01792823, -0.09167993, 0.01533425, -0.01064435, -0.09707557,  0.22708979, -0.05149043, -0.08824956, -0.06267489, -0.01708418,  0.23643188,  0.16007985, -0.01498417,  0.02098352, -0.02181685,  0.11432847, -0.18134783, 0.08841863,  0.07719498,  0.08711237,  0.04825372,  0.09451386, -0.04723743,  0.03988895,  0.07965464, -0.18946315,  0.07275526, 0.04725489,  0.00468429, -0.05424148,  0.00258533,  0.21708301, 0.13386893, -0.10268205, -0.11519437,  0.12464185, -0.11972477, 0.0076764 ,  0.07027947, -0.14508457, -0.18435466, -0.2220473 , 0.10926897,  0.35384247,  0.08600141, -0.14343464, -0.00359992, -0.12797044, -0.04468407,  0.0458146 , -0.00036053, -0.1260138 , -0.01638346, -0.13420668,  0.06053462,  0.13769779,  0.01063394, -0.06730839,  0.21319255, -0.03024589, -0.00797784,  0.03337118, 0.03299601, -0.07148667,  0.05303938, -0.08697553,  0.02529288, 0.14805099, -0.06713539, -0.01860933,  0.03342337, -0.16720949, 0.09504434,  0.00657883, -0.00571885,  0.03074568,  0.04273393,-0.23216605, -0.05640813,  0.16825019, -0.22020227,  0.15109515,0.13512151,  0.07386337,  0.10670583,  0.05183314,  0.06663342,-0.01184203,  0.01027293, -0.10881106,  0.03098165,  0.07032161,0.01464648,  0.03970058,  0.03728874]
#arr=np.array([-0.16204873,  0.05700064,  0.09044103, -0.0289933,  0.0105991, -0.06313304,  0.02532312, -0.06310672,  0.19280991, -0.06976435,0.27877778, -0.02801619, -0.16462296, -0.08764254,  0.0184108 ,0.10018795, -0.1614228 , -0.07778311, -0.05854391, -0.09281124,0.03796965, -0.06505482,  0.08574302,  0.08136091, -0.13039035,-0.33689976, -0.12185112, -0.17633946,  0.04835968, -0.12887856, 0.03734888, -0.03419122, -0.13015796, -0.01792823, -0.09167993, 0.01533425, -0.01064435, -0.09707557,  0.22708979, -0.05149043, -0.08824956, -0.06267489, -0.01708418,  0.23643188,  0.16007985, -0.01498417,  0.02098352, -0.02181685,  0.11432847, -0.18134783, 0.08841863,  0.07719498,  0.08711237,  0.04825372,  0.09451386, -0.04723743,  0.03988895,  0.07965464, -0.18946315,  0.07275526, 0.04725489,  0.00468429, -0.05424148,  0.00258533,  0.21708301, 0.13386893, -0.10268205, -0.11519437,  0.12464185, -0.11972477, 0.0076764 ,  0.07027947, -0.14508457, -0.18435466, -0.2220473 , 0.10926897,  0.35384247,  0.08600141, -0.14343464, -0.00359992, -0.12797044, -0.04468407,  0.0458146 , -0.00036053, -0.1260138 , -0.01638346, -0.13420668,  0.06053462,  0.13769779,  0.01063394, -0.06730839,  0.21319255, -0.03024589, -0.00797784,  0.03337118, 0.03299601, -0.07148667,  0.05303938, -0.08697553,  0.02529288, 0.14805099, -0.06713539, -0.01860933,  0.03342337, -0.16720949, 0.09504434,  0.00657883, -0.00571885,  0.03074568,  0.04273393,-0.23216605, -0.05640813,  0.16825019, -0.22020227,  0.15109515,0.13512151,  0.07386337,  0.10670583,  0.05183314,  0.06663342,-0.01184203,  0.01027293, -0.10881106,  0.03098165,  0.07032161,0.01464648,  0.03970058,  0.03728874])
arr=np.array([fenco])
encodings=[(arr)]


userIDs = []
    # get encoding of detected faces
    
    
    # loop over the encodings
for encoding in encodings:
    # attempt to match each face in the input image to our known
    # encodings
    matches = face_recognition.compare_faces(faceData["encodings"],
                                                 encoding, 0.5)
        # matches contains a list of True/False values indicating
        # which known_face_encodings match the face encoding to check
    id = "Unknown"
        # check to see if we have found a match i.e. we have at least
        # one True value in matches
    if True in matches:
        matchedIdxs = []
            # find the indexes of all matched faces then initialize a
            # dictionary to count the total number of times each face
            # was matched
        for (idx, value) in enumerate(matches):
            if value:
                matchedIdxs.append(idx)
            
            counts = {}
            # loop over the matched indexes and maintain a count for
            # each recognized face
            for i in matchedIdxs:
                id = faceData["ids"][i]
                counts[id] = counts.get(id, 0) + 1
            # determine the recognized face with the largest number of
            # votes (note: in the event of an unlikely tie Python will
            # select first entry in the dictionary)
            id = max(counts, key=counts.get)
            if(counts[id] < (maxImgs * conf)):
                id = "Unknown"

    # update the list of ids
    userIDs.append(id)

    # loop over the recognized faces
    print(id)
      
cv2.destroyAllWindows()